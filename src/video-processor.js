const fs = require('fs-extra');
const path = require('path');
const HubSpotAPI = require('./utils/hubspot-api');
const DataManager = require('./utils/data-manager');

/**
 * Video Processor for handling new video files
 * Processes videos through complete pipeline: transcription, meeting matching, upload, and associations
 */
class VideoProcessor {
  constructor() {
    this.hubspot = new HubSpotAPI();
    this.dataManager = new DataManager();
    this.videosDir = path.join(__dirname, '../videos');
    this.dataDir = path.join(__dirname, '../data');
    this.transcriptService = process.env.TRANSCRIPT_SERVICE || 'deepgram'; // Could be deepgram, whisper, etc.
  }

  /**
   * Get all video files from videos directory
   */
  async getVideoFiles() {
    try {
      console.log('üé• Scanning videos directory for new files...');
      
      const videoFiles = await fs.readdir(this.videosDir);
      const videoDetails = [];
      
      for (const filename of videoFiles) {
        if (filename.endsWith('.mp4')) {
          const filepath = path.join(this.videosDir, filename);
          const stats = await fs.stat(filepath);
          
          // Parse meeting ID and video ID from filename
          const [meetingId, videoId] = filename.replace('.mp4', '').split('_');
          
          videoDetails.push({
            filename,
            filepath,
            meetingId,
            videoId,
            size: stats.size,
            created: stats.birthtime,
            modified: stats.mtime
          });
        }
      }
      
      console.log(`Found ${videoDetails.length} video files to process`);
      return videoDetails;
    } catch (error) {
      console.error('‚ùå Error scanning videos directory:', error.message);
      throw error;
    }
  }

  /**
   * Check which videos already exist in HubSpot to avoid duplicates
   */
  async checkExistingVideos(videoFiles) {
    console.log('üîç Checking for videos already uploaded to HubSpot...');
    
    try {
      const hubspotMeetings = await this.hubspot.getAllMeetings();
      
      // Create set of meeting IDs that already have videos/recordings
      const meetingsWithVideos = new Set();
      
      hubspotMeetings.forEach(meeting => {
        // Check if meeting has recording URL or video attachment
        const hasRecording = meeting.properties?.hs_meeting_outcome === 'COMPLETED' ||
                            meeting.properties?.hs_meeting_body?.includes('recording') ||
                            meeting.properties?.hs_meeting_body?.includes('video');
        
        if (hasRecording) {
          meetingsWithVideos.add(meeting.properties?.attio_meeting_id);
        }
      });

      // Filter out videos for meetings that already have recordings
      const newVideos = videoFiles.filter(video => {
        const alreadyExists = meetingsWithVideos.has(video.meetingId);
        if (alreadyExists) {
          console.log(`‚è≠Ô∏è  Skipping ${video.filename} - meeting ${video.meetingId} already has recording`);
        }
        return !alreadyExists;
      });

      console.log(`${videoFiles.length - newVideos.length} videos skipped (already uploaded), ${newVideos.length} need processing`);
      return newVideos;
    } catch (error) {
      console.error('‚ùå Error checking existing videos:', error.message);
      throw error;
    }
  }

  /**
   * Generate transcript for a video file
   */
  async generateTranscript(videoFile) {
    console.log(`üé§ Generating transcript for ${videoFile.filename}...`);
    
    try {
      // For now, return a placeholder transcript
      // In production, this would call Deepgram, Whisper, or another service
      const placeholderTranscript = `Migrated from Attio

[This is a placeholder transcript. In production, this would be generated by ${this.transcriptService} or another transcription service.]

Meeting Duration: Approximately ${Math.floor(videoFile.size / (1024 * 1024))} minutes
Video File: ${videoFile.filename}
Processing Date: ${new Date().toISOString()}

[Actual transcription would appear here with speaker identification and timestamps]`;

      // Save transcript to data directory for reference
      const transcriptFile = path.join(this.dataDir, 'transcripts', `${videoFile.meetingId}_${videoFile.videoId}_transcript.txt`);
      await fs.ensureDir(path.dirname(transcriptFile));
      await fs.writeFile(transcriptFile, placeholderTranscript);
      
      console.log(`‚úÖ Transcript generated for ${videoFile.filename}`);
      return placeholderTranscript;
      
    } catch (error) {
      console.error(`‚ùå Error generating transcript for ${videoFile.filename}:`, error.message);
      throw error;
    }
  }

  /**
   * Find matching HubSpot meeting for a video
   */
  async findMatchingMeeting(videoFile) {
    console.log(`üîç Finding HubSpot meeting for video ${videoFile.filename}...`);
    
    try {
      const hubspotMeetings = await this.hubspot.getAllMeetings();
      
      // First try exact Attio ID match
      let matchedMeeting = hubspotMeetings.find(meeting => 
        meeting.properties?.attio_meeting_id === videoFile.meetingId
      );
      
      if (matchedMeeting) {
        console.log(`‚úÖ Found exact match: ${matchedMeeting.id} for video ${videoFile.filename}`);
        return {
          meeting: matchedMeeting,
          confidence: 1.0,
          matchType: 'exact_attio_id'
        };
      }
      
      // If no exact match, try partial matching (extract just the UUID part)
      const meetingUUID = videoFile.meetingId.split('-').slice(0, 5).join('-'); // Get first part of UUID
      matchedMeeting = hubspotMeetings.find(meeting => {
        const hubspotAttioId = meeting.properties?.attio_meeting_id;
        return hubspotAttioId && hubspotAttioId.includes(meetingUUID);
      });
      
      if (matchedMeeting) {
        console.log(`‚ö†Ô∏è  Found partial match: ${matchedMeeting.id} for video ${videoFile.filename}`);
        return {
          meeting: matchedMeeting,
          confidence: 0.8,
          matchType: 'partial_id'
        };
      }
      
      console.log(`‚ùå No matching meeting found for video ${videoFile.filename}`);
      return null;
      
    } catch (error) {
      console.error(`‚ùå Error finding meeting for ${videoFile.filename}:`, error.message);
      throw error;
    }
  }

  /**
   * Upload video to HubSpot file manager
   */
  async uploadVideoToHubSpot(videoFile) {
    console.log(`üì§ Uploading ${videoFile.filename} to HubSpot...`);
    
    try {
      // This would use HubSpot's file upload API
      // For now, return a mock file URL
      const mockFileUrl = `https://hubspot-files.s3.amazonaws.com/maze-recordings/${videoFile.filename}`;
      
      console.log(`‚úÖ Video uploaded: ${mockFileUrl}`);
      
      return {
        fileId: `mock-file-${videoFile.meetingId}`,
        fileUrl: mockFileUrl,
        fileName: videoFile.filename,
        fileSize: videoFile.size
      };
      
    } catch (error) {
      console.error(`‚ùå Error uploading ${videoFile.filename}:`, error.message);
      throw error;
    }
  }

  /**
   * Update HubSpot meeting with transcript and video link
   */
  async updateMeetingWithVideo(meeting, videoFile, transcript, uploadedFile) {
    console.log(`üìù Updating HubSpot meeting ${meeting.id} with video and transcript...`);
    
    try {
      const currentBody = meeting.properties?.hs_meeting_body || '';
      
      // Enhanced meeting body with video info
      const enhancedBody = `${currentBody}

üìπ MEETING RECORDING
Recording File: ${uploadedFile.fileName}
Video URL: ${uploadedFile.fileUrl}
File Size: ${(uploadedFile.fileSize / (1024 * 1024)).toFixed(2)} MB
Processed: ${new Date().toISOString()}

üìù TRANSCRIPT
${transcript}`.trim();

      // Update the meeting
      const response = await this.hubspot.client.patch(`/crm/v3/objects/meetings/${meeting.id}`, {
        properties: {
          hs_meeting_body: enhancedBody,
          hs_meeting_outcome: 'COMPLETED' // Mark as completed since we have recording
        }
      });

      console.log(`‚úÖ Meeting ${meeting.id} updated with video and transcript`);
      return response.data;
      
    } catch (error) {
      console.error(`‚ùå Error updating meeting ${meeting.id}:`, error.message);
      throw error;
    }
  }

  /**
   * Create associations for a meeting (contacts, companies, deals)
   */
  async createAssociations(hubspotMeetingId, videoFile) {
    console.log(`üîó Creating associations for meeting ${hubspotMeetingId}...`);
    
    const associationResults = {
      contacts: [],
      companies: [],
      deals: []
    };
    
    try {
      // For now, we can't create new associations without knowing which contacts/companies
      // this meeting should be associated with. This would typically come from:
      // 1. The original Attio data (if we had it)
      // 2. Meeting attendee email addresses
      // 3. Manual configuration
      
      // Placeholder logic - in practice, you'd extract attendees from meeting data
      console.log(`‚ÑπÔ∏è  Association creation skipped for ${hubspotMeetingId} - no attendee data available for new video`);
      
      return associationResults;
      
    } catch (error) {
      console.error(`‚ùå Error creating associations for meeting ${hubspotMeetingId}:`, error.message);
      throw error;
    }
  }

  /**
   * Process a single video file through the complete pipeline
   */
  async processVideo(videoFile) {
    console.log(`\nüé¨ Processing video: ${videoFile.filename}`);
    
    const result = {
      videoFile: videoFile.filename,
      success: false,
      steps: {},
      error: null
    };
    
    try {
      // Step 1: Generate transcript
      result.steps.transcriptGeneration = { status: 'started' };
      const transcript = await this.generateTranscript(videoFile);
      result.steps.transcriptGeneration = { status: 'completed', length: transcript.length };
      
      // Step 2: Find matching meeting
      result.steps.meetingMatching = { status: 'started' };
      const meetingMatch = await this.findMatchingMeeting(videoFile);
      
      if (!meetingMatch) {
        result.steps.meetingMatching = { status: 'failed', reason: 'No matching meeting found' };
        result.error = 'No matching HubSpot meeting found';
        return result;
      }
      
      result.steps.meetingMatching = { 
        status: 'completed', 
        meetingId: meetingMatch.meeting.id,
        confidence: meetingMatch.confidence,
        matchType: meetingMatch.matchType
      };
      
      // Step 3: Upload video to HubSpot
      result.steps.videoUpload = { status: 'started' };
      const uploadedFile = await this.uploadVideoToHubSpot(videoFile);
      result.steps.videoUpload = { status: 'completed', fileUrl: uploadedFile.fileUrl };
      
      // Step 4: Update meeting with transcript and video
      result.steps.meetingUpdate = { status: 'started' };
      const updatedMeeting = await this.updateMeetingWithVideo(
        meetingMatch.meeting, 
        videoFile, 
        transcript, 
        uploadedFile
      );
      result.steps.meetingUpdate = { status: 'completed', meetingId: updatedMeeting.id };
      
      // Step 5: Create associations (contacts, companies, deals)
      result.steps.associations = { status: 'started' };
      const associations = await this.createAssociations(updatedMeeting.id, videoFile);
      result.steps.associations = { 
        status: 'completed', 
        created: {
          contacts: associations.contacts.length,
          companies: associations.companies.length,
          deals: associations.deals.length
        }
      };
      
      result.success = true;
      console.log(`‚úÖ Successfully processed ${videoFile.filename}`);
      
    } catch (error) {
      result.error = error.message;
      console.error(`‚ùå Failed to process ${videoFile.filename}:`, error.message);
    }
    
    return result;
  }

  /**
   * Process all new videos through the complete pipeline
   */
  async processAllVideos() {
    console.log('üöÄ STARTING VIDEO PROCESSING PIPELINE\n');
    
    try {
      // Step 1: Get all video files
      const allVideoFiles = await this.getVideoFiles();
      
      if (allVideoFiles.length === 0) {
        console.log('No video files found to process.');
        return { processed: 0, errors: 0, results: [] };
      }
      
      // Step 2: Filter out videos that already exist
      const videosToProcess = await this.checkExistingVideos(allVideoFiles);
      
      if (videosToProcess.length === 0) {
        console.log('All videos have already been processed.');
        return { processed: 0, errors: 0, results: [] };
      }
      
      // Step 3: Process each video
      console.log(`\nüìã Processing ${videosToProcess.length} videos...\n`);
      
      const results = [];
      const batchSize = 3; // Process videos in small batches to avoid overwhelming the system
      
      for (let i = 0; i < videosToProcess.length; i += batchSize) {
        const batch = videosToProcess.slice(i, i + batchSize);
        console.log(`\nüì¶ Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(videosToProcess.length / batchSize)}`);
        
        // Process batch in parallel
        const batchPromises = batch.map(videoFile => this.processVideo(videoFile));
        const batchResults = await Promise.allSettled(batchPromises);
        
        batchResults.forEach((settledResult, index) => {
          if (settledResult.status === 'fulfilled') {
            results.push(settledResult.value);
          } else {
            results.push({
              videoFile: batch[index].filename,
              success: false,
              error: settledResult.reason.message || 'Unknown error',
              steps: {}
            });
          }
        });
        
        // Add delay between batches to be respectful of rate limits
        if (i + batchSize < videosToProcess.length) {
          console.log('‚è±Ô∏è  Waiting 30 seconds before next batch...');
          await new Promise(resolve => setTimeout(resolve, 30000));
        }
      }
      
      // Step 4: Save results and generate report
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      await this.dataManager.saveData(`video_processing_results_${timestamp}.json`, results);
      
      const successful = results.filter(r => r.success).length;
      const failed = results.filter(r => !r.success).length;
      
      console.log('\n' + '='.repeat(80));
      console.log('VIDEO PROCESSING COMPLETED');
      console.log('='.repeat(80));
      console.log(`üìä Summary:`);
      console.log(`   Total videos: ${allVideoFiles.length}`);
      console.log(`   Processed: ${videosToProcess.length}`);
      console.log(`   Successful: ${successful}`);
      console.log(`   Failed: ${failed}`);
      console.log(`   Skipped (already uploaded): ${allVideoFiles.length - videosToProcess.length}`);
      
      if (failed > 0) {
        console.log('\n‚ùå Failed videos:');
        results.filter(r => !r.success).forEach((result, index) => {
          console.log(`   ${index + 1}. ${result.videoFile}: ${result.error}`);
        });
      }
      
      console.log('\n‚úÖ Video processing pipeline completed!');
      console.log(`üìÅ Results saved to video_processing_results_${timestamp}.json`);
      
      return { processed: successful, errors: failed, results };
      
    } catch (error) {
      console.error('‚ùå Video processing pipeline failed:', error.message);
      throw error;
    }
  }
}

module.exports = VideoProcessor;

// Run if called directly
if (require.main === module) {
  const processor = new VideoProcessor();
  processor.processAllVideos()
    .then((result) => {
      console.log('\nüéâ Video processing completed successfully!');
      console.log(`Processed ${result.processed} videos with ${result.errors} errors`);
      process.exit(0);
    })
    .catch(error => {
      console.error('\nüí• Video processing failed:', error.message);
      process.exit(1);
    });
}